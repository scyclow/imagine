<!DOCTYPE html>
<html>
<head>
  <title>Imagine Coin - Whitepaper</title>


  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="HandheldFriendly" content="true">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge">
  <meta id="header-theme" name="theme-color" content="#ffffff">

  <meta name="twitter:image" content="https://steviep.xyz/IC-thumbnail.png">
  <meta name="og:image" property="og:image" content="https://steviep.xyz/IC-thumbnail.png">
  <meta name="og:image:alt" content="Imagine Coin">
  <meta name="title" content="Imagine Coin - Whitepaper">
  <meta name="og:title" content="Imagine Coin - Whitepaper">
  <meta name="twitter:title" content="Imagine Coin - Whitepaper">
  <meta property="og:site_name" content="Imagine Coin - Whitepaper">

  <meta name="description" content="Imagine Coin is a conceptual art piece designed to explore the relationship between arbitrary Replicated State Machine transactions and monetary value.">
  <meta name="og:description" content="Imagine Coin is a conceptual art piece designed to explore the relationship between arbitrary Replicated State Machine transactions and monetary value.">
  <meta name="twitter:card" content="summary_large_image">
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://steviep.xyz/imagine">
  <meta name="twitter:url" content="https://steviep.xyz/imagine">
  <meta name="keywords" content="Imagine Coin, imagine, coin, whitepaper, crypto, cryptocurrency, nft, nfts, art, conceptual, conceptual art, meme coin, token, steviep, steve, pikelny, steve pikelny">

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Cutive+Mono&family=Poiret+One&family=Roboto+Slab:wght@200&display=swap" rel="stylesheet">


  <style type="text/css">
    * {
      margin: 0;
      padding: 0;
      color: #3c3c3c;
      font-family: 'Poiret One', sans-serif;
    }

    p, label, label span, li , li span{
      font-family: 'Roboto Slab', serif;
    }

    main {
      margin-bottom: 5em;
    }

    body {
      background: #fdfdfd;
    }

    h1, h2 {
      text-align: center;
      padding: 0 0.4em;
    }

    h1 {
      font-size: 6em;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    h2 {
      margin-top: 0.5em;
      font-size: 2em;
    }


    p, ol, ul {
      max-width: 750px;
      margin: auto;
      line-height: 1.6;
      font-size: 1.3em;
      padding: 1em;
      padding-bottom: 0;
    }

    li {
      margin-left: 2em;
    }

    section {
      margin-bottom: 1em;
    }



    footer {
      padding: 1em;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }
    footer > * {
      padding: 0.25em;
    }

    a {
      color: #e10be3;
    }

    .hero {
      display: flex;
      justify-content: center;
      align-items: center;
      height: 40vh;
      width: 100vw;
      overflow: hidden;
    }



    .center {
      display: flex;
      align-items: center;
      justify-content: center;
      margin: auto;
    }



    .accent {
      color: #e10be3;
    }

    .label {
      text-decoration: underline;
    }

    #sampleCode {
      font-family: 'Cutive Mono', monospace;
      background-color: #e3e9e8;
      max-width: 750px;
      margin: 1em auto;
      padding: 1em;
    }



    @media (max-width: 612px) {
      body {
        font-size: 12px;
      }
    }

  </style>
</head>
<body>
  <main>
    <section>
      <div class="hero">
        <div>
          <h1>
            <div>
              Imagine Coin
            </div>
          </h1>
          <h2 class="accent">Whitepaper</h2>
        </div>
      </div>
    </section>


    <section>
      <h2>Summary</h2>
      <p>
        Imagine Coin is a conceptual art piece designed to explore the relationship between arbitrary Replicated State Machine transactions and monetary value. It accomplishes this with a contract that conforms to a standard ERC-20 interface, but does not token balances or allowances in the contract state. This means that contract users are forced calculate token balances by using their imagination to interpret all Imagine Coin activity.
      </p>

      <p>For an example of what an off-chain state machine might look like, see the example code at the bottom of this page, as well as the <a href="./stateMachine">Imagine Coin Explorer</a>.</p>

    </section>
    <section><h1 class="center accent">~</h1></section>


    <section>
      <h2>Replicated State Machines</h2>
      <p>
        State Machine Replication is the key concept to understand the application layer of blockchains. While various cryptographic and network consensus mechanisms are used to determine the validity and order of transactions, smart contracts give meaning to these transactions. Given the same ordered list of events, any state machine within a network should be able to deterministically calculate its own state from scratch.</p>

      <p>Consider the following set of events:</p>
      <ol>
        <li>Alice mints $10</li>
        <li>Alice transfers $8 to Bob</li>
        <li>Alice transfers $3 to Charlie</li>
      </ol>

      <p>As long as a network agrees on the rules of the state machine (along with the order of events), each node should be able to independently arrive at the same state. Of course, changing the rules would lead to a different end state. In this example transaction 3 could fail, or it could leave Alice with -$1. Depending on the rules, changing the order of transactions could have no effect on the state, or it could leave Bob with $0.</p>

    </section>
    <section><h1 class="center accent">~</h1></section>

    <section>
      <h2>Integers & Value</h2>

      <p>One popular use of smart contracts on the Ethereum network is modeling ownership of fungible and non fungible tokens. While some contracts are fairly complicated, the rule set governing the actual ownership of tokens tends to be quite simple. For fungible tokens, this amounts to incrementing and decrementing integers that are assigned to addresses. </p>

      <p>People tend to have strong emotional attachement to these integers. They can use these integers to make other blockchain integers go up and down, they can prominently display these integers on websites for others to see, or they can use their integers to convince large centralized institutions to increment integers in a central database. These integers can even lead to acquiring pieces of paper, which may be exchanged for real, non-digital things such as sandwiches.</p>

      <p>While this system is largely decentralized and trustless, it's also largely immaterial. Integer values and physical paper might be fairly concrete, but the meaning behind them is determined entirely by the imagination of the participants. Moreover, getting from one integer to another integer to another integer to a piece of paper to a sandwich requires multiple participants in the chain to share similar ideas around abstract concepts such as <em>value</em> and <em>ownership</em>.</p>
    </section>
    <section><h1 class="center accent">~</h1></section>


    <section>
      <h2>Imagine Coin</h2>

      <p>Where the existing token ecosystem relies on collective imagination to define the meaning of arbitrary values stored on the blockchain, Imagine Coin takes things one step further: it relies on collective imagination to define the rules that determine these values.</p>

      <p>Imagine Coin is a smart contract that defines functions for the full ERC-20 interface, but refrains from implementing any logic for these functions. This means that the Ethereum blockchain determines the order and validity of the contract's transactions, but no logic or storage of data is performed. Users of the contract are free to determine the meaning behind these transactions. The execution of the state machine takes place in their imaginations.</p>

      <p>The imaginary state machine consists of the following events, which are presented with non-binding suggestions as to what they could potentially mean.</p>

      <ul>
        <li><span class="label">Mint</span>: Increment the caller's token balance by the amount specified. Fail and revert if the transaction does not include enough Ether at the price of 0.0001 ETH per token. Fail and revert if the specified amount of tokens would increase to total mint count above 1 million.</li>
        <li><span class="label">Burn</span>: Decrement the caller's token balance by the amount specified. Fail and revert if they attempt to burn an amount greater than their current balance.</li>
        <li><span class="label">Approve</span>: Set an allowance for spender. Fail and revert if the amount is greater than the sender's balance.</li>
        <li><span class="label">Transfer</span>: Decrement the sender's token balance by the amount specified, and increment the recipient's token balance by the amount specified. Fail and revert if this amount is greater than the sender's balance. Fail and revert if the function caller is not the sender, or if the amount is greater than the caller's allowance. If the caller is an approved spender, decrement their allowance by the amount of the transaction.</li>
      </ul>

      <p>These events are emitted by the contract convenience, but do not interoperate with the existing ERC-20 ecosystem. </p>

    </section>
    <section><h1 class="center accent">~</h1></section>

    <section>
      <h2>Example Code</h2>
      <pre id="sampleCode"> </pre>
    </section>
    <section><h1 class="center accent">~</h1></section>

    <section>
      <h2><a href="./">Home</a></h2>

    </section>


  </main>

  <footer>
    <div><a href="https://twitter.com/steviepxyz" target="_blank" rel="nofollow">twitter</a></div>
    <div><a href="https://discord.gg/9uA8WBFpcB" target="_blank" rel="nofollow">discord</a></div>
    <div><a href="https://steviep.xyz" target="_blank">steviep</a> (c) 2021</div>
  </footer>
</body>

<script type="text/javascript">
  document.getElementById('sampleCode').innerHTML = `
type ImagineMintEvent = {
  event: 'ImagineMint',
  args: []
}

type ImagineBurnEvent = {
  event: 'ImagineBurn',
  args: []
}

type ImagineTransferEvent = {
  event: 'ImagineTransfer',
  args: []
}

type ImagineApproveEvent = {
  event: 'ImagineApprove',
  args: []
}

type Event =
  | ImagineMintEvent
  | ImagineBurnEvent
  | ImagineTransferEvent
  | ImagineApproveEvent

type Address = string

type Balances = { [owner: Address]: number }
type Allowances = { [owner: Address]: { [spender: Address]: number } }

class StateMachine {
  // These numbers are adjusted by 18 decimal places for readability
  mintPrice = 0.0001
  maxTokens = 1000000
  tokensMinted = 0
  tokensBurnt = 0

  events: Array<Event> = []
  balances: Balances = {}
  allowances: Allowances = {}

  constructor(events: Array<Event>) {
    this.events = events
    events.forEach(e => {
      switch (e.event) {
        case 'ImagineMint': return this.mint(...e.args)
        case 'ImagineBurn': return this.burn(...e.args)
        case 'ImagineTransfer': return this.transfer(...e.args)
        case 'ImagineApprove': return this.approve(...e.args)
      }
    })
  }

  mint(caller: string, amount: number, txValue: number) {
    if (amount * this.mintPrice < txValue) return
    if (amount + this.tokensMinted > this.maxTokens) return

    this.tokensMinted = this.tokensMinted + amount

    if (this.balances[caller]) {
      this.balances[caller] += amount
    } else {
      this.balances[caller] = amount
    }
  }

  burn(caller: string, amount: number) {
    if ((this.balances[caller] || 0) < amount) return
    this.balances[caller] -= amount
    this.tokensBurnt += amount
  }

  transfer(caller: string, from: string, to: string, value: number) {
    if (
      !(
        caller === from ||
        (this.allowances?.[from]?.[caller] || 0) <= value
      )
    ) {
      return
    }
    if ((this.balances[from] || 0) < value) return

    this.balances[from] -= value

    if (this.balances[to]) {
      this.balances[to] += value
    } else {
      this.balances[to] = value
    }

    if (caller !== from) {
      this.approve(from, caller, this.allowances[from][caller] - value)
    }
  }

  approve(caller: string, spender: string, value: number) {
    if ((this.balances[caller] || 0) < value) return

    this.allowances[caller] = {
      [spender]: value
    }

  }
}
  `
  .replace(/&/g, '&amp;')
 .replace(/</g, '&lt;')
 .replace(/>/g, '&gt;')
 .replace(/"/g, '&quot;')
 .replace(/'/g, '&#039;')
</script>

</html>